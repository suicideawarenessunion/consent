<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Scan</title>
  <style>
    body {
      background: black;
      color: white;
      text-align: center;
      font-family: Arial, sans-serif;
    }
    video, canvas {
      border-radius: 10px;
      margin-top: 20px;
      max-width: 90%;
      height: auto;
    }
    #status {
      margin-top: 20px;
      font-size: 18px;
      color: lightgreen;
    }
    #substatus {
      margin-top: 8px;
      font-size: 14px;
      color: orange;
    }
  </style>
</head>
<body>
  <h2>Scan</h2>
  <video id="video" autoplay playsinline></video>
  <canvas id="canvas" style="display:none;"></canvas>
  <div id="status">Waiting for camera...</div>
  <div id="substatus"></div>

  <script>
const API_URL = "https://borrapavani-newdocker.hf.space/predict";
const TRIGGER_OTP_URL = "https://borrapavani-newdocker.hf.space/trigger_otp";
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const statusDiv = document.getElementById("status");
const substatusDiv = document.getElementById("substatus");

let policeCount = 0;
const REQUIRED_FRAMES = 3;
const CAPTURE_INTERVAL_MS = 3000;
let captureLoop = null;

// open front camera
async function startCamera() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } });
    video.srcObject = stream;
    statusDiv.textContent = "Camera starting...";
    waitForVideoReady();
  } catch (err) {
    statusDiv.textContent = "Camera access denied or not available.";
    substatusDiv.textContent = err.message || "";
  }
}

// wait until camera has proper dimensions
function waitForVideoReady() {
  if (video.videoWidth > 0 && video.videoHeight > 0) {
    statusDiv.textContent = "âœ… Camera started. Ready to scan...";
    startCaptureLoop();
  } else {
    requestAnimationFrame(waitForVideoReady);
  }
}

// prediction loop
function startCaptureLoop() {
  if (captureLoop) clearInterval(captureLoop);

  captureLoop = setInterval(async () => {
    if (!video.videoWidth || !video.videoHeight) {
      console.log("Video not ready yet...");
      return;
    }

    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    canvas.toBlob(async (blob) => {
      try {
        const formData = new FormData();
        formData.append("img", blob, "capture.png");
        const res = await fetch(API_URL, { method: "POST", body: formData });
        const result = await res.json();

        if (result?.label === "Police" && result.confidence >= 0.8) {
          policeCount++;
          statusDiv.textContent = `âœ… Detected (${policeCount}/${REQUIRED_FRAMES})`;
          if (policeCount >= REQUIRED_FRAMES) {
            statusDiv.textContent = "ðŸ”” Confirmed â€” triggering OTP...";
            const meta = { camera: "lobby-cam-1", ts: new Date().toISOString() };
            const tRes = await fetch(TRIGGER_OTP_URL, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(meta),
            });
            const j = await tRes.json();
            if (j.entry_url) window.location.href = j.entry_url;
            policeCount = 0;
          }
        } else {
          policeCount = 0;
          statusDiv.textContent = "Rejected";
        }
      } catch (e) {
        substatusDiv.textContent = "Network/API error";
      }
    }, "image/png");
  }, CAPTURE_INTERVAL_MS);
}

startCamera();

// cleanup
window.addEventListener("beforeunload", () => {
  if (captureLoop) clearInterval(captureLoop);
  if (video.srcObject) video.srcObject.getTracks().forEach(t => t.stop());
});
</script>
</body>
</html>